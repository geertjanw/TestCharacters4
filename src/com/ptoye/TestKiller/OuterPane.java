/*
 * OuterPane.java
 *
 * Created on 22 January 2007, 22:10
 */
package com.ptoye.TestKiller;

//import com.ptoye.TestKiller.TestKiller;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import javax.swing.JButton;
import javax.swing.JColorChooser;
import javax.swing.JDialog;
import javax.swing.JLayeredPane;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;

/**
 *
 * @author PToye
 */
public class OuterPane extends javax.swing.JPanel {

  /**
   *
   */
  static final long serialVersionUID = 2L;
//  /**
//   *
//   */
//  enum CurrentColour {
//
//    /**
//     * Square is marked as permanent
//     */
//    PERMANENT,
//    /**
//     * Square is marked with temporary colour
//     */
//    TEMPORARY,
//    /**
//     * Square is marked with current custom colour
//     */
//    CUSTOM,
//    /**
//     * Square is marked with deep custom colour
//     */
//    CUSTOM2
//  }
  private static final int GRID_LEVEL = 2;
  private static final int REGIONS_LEVEL = 3;
  private static final int THICK_WIDTH = 4;
  private static final int THIN_WIDTH = 2;
  private static final int SQUARES = 3;  //standard sudoku
  /**
   * Total number of squares in a row or column
   */
  static final int BIGSQUARES = SQUARES * SQUARES;
  private static final int START_X = 0;
  private static final int START_Y = 0;
  private static int gameNo = 1;
  private static Timer gameTimer = new Timer();
  /**
   * Colour for permanent squares
   */
  static Color PERM_COLOUR = Color.BLACK;
  private static Color TEMP_COLOUR = new Color(192, 90, 192);
//  private static Color ERROR_BACK_COLOUR = Color.RED;
//  private static Color BUG_BACK_COLOUR = Color.YELLOW;
  private static Color INITIAL_CUSTOM_COLOUR = Color.CYAN;
  /**
   * Maximum total in a region
   */
  private static final int MAX_TOTAL = BIGSQUARES * (BIGSQUARES + 1) / 2;

  /**
   * characters for arrows in toolbar buttons
   *
   */
  private static final String upDownArrow="" + '\u2195'; // characters for markers
  private static final String leftRightArrow="" + '\u2194';
  private static final String smallSquare="" + '\u25A1';

  /**
   * set to get region values from a spinner rather than typing will be set from
   * a preference sometime
   */
  private static boolean inputFromSpinner = false;
  //TODO set from a preference
  private GamePanel gp = null;
  private boolean timing;
  private TestKiller tk;

  /**
   * Creates new form OuterPane should never be called!
   */
//  public OuterPane() {
//    initialiseNew();
//  }
  /**
   * does the work for the constructor
   */
  private void initialiseNew() {
    initComponents();
    pnlButtons.setSize(pnlButtons.getSize().width, 250);
//    btnCol.setText(upDownArrow);
//    btnRow.setText(leftRightArrow);
//    btnSq.setText(smallSquare);
//    gp = new GamePanel();
//    gp.addListeners();
//    add(gp, BorderLayout.CENTER);
    timing = false;
    setVisible(true);

  }

  /**
   * Constructor which should be called
   *
   * @param tk The Outer TestKiller frame
   */
  public OuterPane(TestKiller tk) {
    this.tk = tk;
    initialiseNew();
  }

  /**
   * Starts the timer going
   */
  void startTimer() {
    timing = true;
  }

  /**
   * stops the timer
   */
  void stopTimer() {
    timing = false;
  }

  /**
   * Gets the inner GamePanel for this game (so that users can access game
   * methods)
   *
   * @return the GamePanel
   */
  GamePanel getGp() {
    return gp;
  }

//  /**
//   * Prints details of the OuterPane for debugging
//   */
//  void print() {
//    System.out.println("OuterPane " + this);
//    System.out.println(" Panel " + pnlButtons);
//    for (int i = 0; i < pnlButtons.getComponentCount(); i++) {
//      System.out.println("  Comp " + pnlButtons.getComponent(i));
//    }
//    if (gp != null) {
//      gp.print();
//    }
//  }
  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    bgColours = new javax.swing.ButtonGroup();
    pnlButtons = new javax.swing.JPanel();
    btnStart = new javax.swing.JButton();
    pnlColourButtons = new javax.swing.JPanel();
    rbtPerm = new javax.swing.JRadioButton();
    rbtTemp = new javax.swing.JRadioButton();
    rbtCustom = new javax.swing.JRadioButton();
    rbtCustom2 = new javax.swing.JRadioButton();
    btnUndo = new javax.swing.JButton();
    btnRedo = new javax.swing.JButton();
    btnSq = new javax.swing.JButton();
    btnRow = new javax.swing.JButton();
    btnCol = new javax.swing.JButton();
    btnPtoT = new javax.swing.JButton();
    btnTtoP = new javax.swing.JButton();
    btnSwap = new javax.swing.JButton();
    btnSwapPerm = new javax.swing.JButton();
    btnCustomCol = new javax.swing.JButton();
    filler1 = new javax.swing.Box.Filler(new java.awt.Dimension(0, 0), new java.awt.Dimension(0, 0), new java.awt.Dimension(32767, 0));
    lblGameTime = new javax.swing.JLabel();

    FormListener formListener = new FormListener();

    addComponentListener(formListener);
    setLayout(new java.awt.BorderLayout());

    pnlButtons.setLayout(new javax.swing.BoxLayout(pnlButtons, javax.swing.BoxLayout.LINE_AXIS));

    btnStart.setText("Start");
    btnStart.setToolTipText("Start game");
    btnStart.setMargin(new java.awt.Insets(2, 5, 2, 5));
    btnStart.setMaximumSize(new java.awt.Dimension(45, 23));
    btnStart.setMinimumSize(new java.awt.Dimension(45, 23));
    btnStart.setPreferredSize(new java.awt.Dimension(50, 23));
    pnlButtons.add(btnStart);

    pnlColourButtons.setLayout(new javax.swing.BoxLayout(pnlColourButtons, javax.swing.BoxLayout.Y_AXIS));

    bgColours.add(rbtPerm);
    rbtPerm.setMnemonic('P');
    rbtPerm.setText("Permanent");
    rbtPerm.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    rbtPerm.setMargin(new java.awt.Insets(0, 0, 0, 0));
    pnlColourButtons.add(rbtPerm);

    bgColours.add(rbtTemp);
    rbtTemp.setForeground(new java.awt.Color(255, 0, 255));
    rbtTemp.setMnemonic('T');
    rbtTemp.setText("Temporary");
    rbtTemp.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    rbtTemp.setMargin(new java.awt.Insets(0, 0, 0, 0));
    pnlColourButtons.add(rbtTemp);

    bgColours.add(rbtCustom);
    rbtCustom.setForeground(new java.awt.Color(0, 255, 255));
    rbtCustom.setMnemonic('C');
    rbtCustom.setText("Custom");
    rbtCustom.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    rbtCustom.setMargin(new java.awt.Insets(0, 0, 0, 0));
    pnlColourButtons.add(rbtCustom);

    bgColours.add(rbtCustom2);
    rbtCustom2.setForeground(new java.awt.Color(0, 153, 153));
    rbtCustom2.setText("Custom 2");
    rbtCustom2.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    rbtCustom2.setMargin(new java.awt.Insets(0, 0, 0, 0));
    pnlColourButtons.add(rbtCustom2);

    pnlButtons.add(pnlColourButtons);

    btnUndo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/undo_16.gif"))); // NOI18N
    btnUndo.setMnemonic('z');
    btnUndo.setToolTipText("Undo last move");
    btnUndo.setMaximumSize(new java.awt.Dimension(31, 25));
    btnUndo.setMinimumSize(new java.awt.Dimension(31, 25));
    btnUndo.setPreferredSize(new java.awt.Dimension(31, 25));
    pnlButtons.add(btnUndo);

    btnRedo.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/redo_16.gif"))); // NOI18N
    btnRedo.setMnemonic('y');
    btnRedo.setToolTipText("Redo");
    btnRedo.setMaximumSize(new java.awt.Dimension(31, 25));
    btnRedo.setMinimumSize(new java.awt.Dimension(31, 25));
    btnRedo.setPreferredSize(new java.awt.Dimension(31, 25));
    pnlButtons.add(btnRedo);

    btnSq.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
    btnSq.setText("?");
    btnSq.setToolTipText("Confine selected squares to square");
    btnSq.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnSq);

    btnRow.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
    btnRow.setText("?");
    btnRow.setToolTipText("Confine selected squares to row");
    btnRow.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnRow);

    btnCol.setFont(new java.awt.Font("SansSerif", 0, 12)); // NOI18N
    btnCol.setText("?");
    btnCol.setToolTipText("Confine selected squares to column");
    btnCol.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnCol);

    btnPtoT.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/PtoT.gif"))); // NOI18N
    btnPtoT.setToolTipText("Make selected squares temporary");
    btnPtoT.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnPtoT);

    btnTtoP.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/TtoP.gif"))); // NOI18N
    btnTtoP.setToolTipText("Make selected squares permanent");
    btnTtoP.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnTtoP);

    btnSwap.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/Swap.gif"))); // NOI18N
    btnSwap.setToolTipText("Swap");
    btnSwap.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnSwap);

    btnSwapPerm.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/Swap_Perm.gif"))); // NOI18N
    btnSwapPerm.setToolTipText("Swap & make permanent");
    btnSwapPerm.setMargin(new java.awt.Insets(2, 5, 2, 5));
    pnlButtons.add(btnSwapPerm);

    btnCustomCol.setForeground(new java.awt.Color(0, 255, 255));
    btnCustomCol.setIcon(new javax.swing.ImageIcon(getClass().getResource("/com/ptoye/TestKiller/images/CustomColour.gif"))); // NOI18N
    btnCustomCol.setToolTipText("Change custom colour");
    btnCustomCol.setMaximumSize(new java.awt.Dimension(70, 23));
    btnCustomCol.setMinimumSize(new java.awt.Dimension(70, 23));
    btnCustomCol.setPreferredSize(new java.awt.Dimension(65, 23));
    pnlButtons.add(btnCustomCol);
    pnlButtons.add(filler1);

    lblGameTime.setText("xx:xx:xx");
    pnlButtons.add(lblGameTime);

    add(pnlButtons, java.awt.BorderLayout.NORTH);
  }

  // Code for dispatching events from components to event handlers.

  private class FormListener implements java.awt.event.ComponentListener {
    FormListener() {}
    public void componentHidden(java.awt.event.ComponentEvent evt) {
    }

    public void componentMoved(java.awt.event.ComponentEvent evt) {
    }

    public void componentResized(java.awt.event.ComponentEvent evt) {
      if (evt.getSource() == OuterPane.this) {
        OuterPane.this.formComponentResized(evt);
      }
    }

    public void componentShown(java.awt.event.ComponentEvent evt) {
    }
  }// </editor-fold>//GEN-END:initComponents

  private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
    if (gp != null && gp.isInitialised()) {
      gp.changeSize();
    }
  }//GEN-LAST:event_formComponentResized

  /**
   * Inner class to OuterPane. It contains the game itself
   */
  class GamePanel extends JLayeredPane
          implements
          MouseListener,
          KeyListener,
          ActionListener
  {

    /**
     * Serialisation ID
     */
    static final long serialVersionUID = 1L;
    private final float DARK_FACTOR = 0.9f;
    private final Color NORMAL_BACK_COLOUR = Color.WHITE;
    private final Color DARK_NORMAL_COLOUR = new Color(
            (int) (NORMAL_BACK_COLOUR.getRed() * DARK_FACTOR),
            (int) (NORMAL_BACK_COLOUR.getGreen() * DARK_FACTOR),
            (int) (NORMAL_BACK_COLOUR.getBlue() * DARK_FACTOR));
    private final Color SELECTED_BACK_COLOUR = Color.PINK;
    private final Color DARK_SEL_BACK_COLOUR = new Color(
            (int) (SELECTED_BACK_COLOUR.getRed() * DARK_FACTOR),
            (int) (SELECTED_BACK_COLOUR.getGreen() * DARK_FACTOR),
            (int) (SELECTED_BACK_COLOUR.getBlue() * DARK_FACTOR));
    private final Color SELECTED_REGION_COLOUR = new Color(180, 180, 255);
    private final Color DARK_SEL_REGION_COLOUR = new Color(
            (int) (SELECTED_REGION_COLOUR.getRed() * DARK_FACTOR),
            (int) (SELECTED_REGION_COLOUR.getGreen() * DARK_FACTOR),
            (int) (SELECTED_REGION_COLOUR.getBlue() * DARK_FACTOR));
    private final Color ERROR_BACK_COLOUR = Color.RED;
    private final Color BUG_BACK_COLOUR = Color.YELLOW;
    private final int SAVE_TYPE = 1;
    /**
     * Square size currently fixed
     */
    static final int SQUARE_SIZE = 60;
    /**
     * Width of lines in display
     */
    static final int FIXED_WIDTH = (SQUARES + 1) * THICK_WIDTH
            + SQUARES * (SQUARES - 1) * THIN_WIDTH;
    /**
     * Total width of display in pixels
     */
    static final int TOTALSIZE = FIXED_WIDTH + BIGSQUARES * SQUARE_SIZE;
    /**
     * Coordinates (X and Y are the same) for start of each square
     */
    int[] coordArray = new int[BIGSQUARES];
    private Region newRegion;
    private int mouseSqX, mouseSqY;
    private boolean leftMouseDown;
    private transient Square draggedSquare = null;
    private transient Square initialDraggedSquare = null;
    private transient boolean firstDrag = false;
    private transient Set<Region> selectedRegions;
    private transient Set<Square> selectedSquares;
//    private transient CurrentColour currColType;
    private transient Color customColour = INITIAL_CUSTOM_COLOUR;
    private transient Color customColour2;
    private transient Color currentRealColor;
    private boolean playing;
    private int regionId = 1;
    private int squareCount, regionTot;
//    private Square[][] squareArray = new Square[BIGSQUARES][BIGSQUARES];
    private Set<Region> regions;
    private ArrayList<Move> moveList;
    private int movePointer;
    private long gameTime = 0;    // time in secs
    private transient int squaresLeft;
    private transient boolean gameFinished = false;
    private transient JColorChooser cc = new JColorChooser(customColour);
    private transient JDialog jd = JColorChooser.createDialog(cc,
            "Choose custom colour", true, cc, this, this);
    private int squareSize = SQUARE_SIZE;
    private int totalSize = TOTALSIZE;
    private int currentSquareSize = SQUARE_SIZE;
    private transient boolean initialised = false;

    /**
     * Creates a new instance of GamePanel
     */
    GamePanel() {
      super();
      initialised = false;

      disableButtons();
      regions = new HashSet<>();
      moveList = new ArrayList<>(2 * BIGSQUARES * BIGSQUARES);
      movePointer = -1;
      totalSize = TOTALSIZE;
      setPreferredSize(new Dimension(totalSize, totalSize));
      setSize(totalSize, totalSize);
      makeGridLayer(true);
      setVisible(true);
      setName("Game-" + gameNo++);
      jd.setVisible(false);

      newRegion = null;
      selectedRegions = new HashSet<>();
      selectedSquares = new HashSet<>();
      playing = false;
      gameFinished = false;
      leftMouseDown = false;
      squareCount = 0;
      regionTot = 0;
      mouseSqX = -1;
      mouseSqY = -1;
      setFocusable(true);
      SwingUtilities.invokeLater(displayTime);
      gameTimer.scheduleAtFixedRate(timerTick, 1000l, 1000l);

      darkenCustom();
      initialised = true;
//      System.out.println("Dark region=" + DARK_SEL_REGION_COLOUR);
//      addListeners();
    }

    public boolean isInitialised() {
      return initialised;
    }

    /**
     * Saves the current game to an output stream
     *
     * @param os Output stream to save to
     */
    void saveGame(ObjectOutputStream os) {
//      try {
//        os.writeInt(SAVE_TYPE);
//        os.writeInt(SQUARES);
//        os.writeBoolean(playing);
//        os.writeInt(regionId);
//        os.writeInt(squareCount);
//        os.writeInt(regionTot);
//        os.writeLong(gameTime);
//        setPointersNull();
//        os.writeObject(squareArray);
//        os.writeObject(regions);
//        os.writeObject(moveList);
//        os.writeInt(movePointer);
//        os.writeObject(customColour);
//        setPointersThis();
//        tk.DisableSave();
//      } catch (IOException ex) {
//        TestKiller.showMessage("I/O error while saving game\n"
//                + ex.getLocalizedMessage());
//        try {
//          os.close();
//        } catch (IOException ex1) {
//        } finally {
//          System.exit(1);
//        }
//      }
    }

    /**
     * Keeps track of the running time for the game
     */
    TimerTask timerTick = new TimerTask() {
      @Override
      public void run() {
//      System.out.println(""+gameTime);
        if (playing && timing && !gameFinished) {
          gameTime++;
          SwingUtilities.invokeLater(displayTime);
        }
      }
    };
    /**
     * Task which displays the running time
     */
    Runnable displayTime = new Runnable() {
      @Override
      public void run() {
        long hr, min, sec;
        sec = gameTime % 60l;
        min = gameTime / 60l;
        hr = min / 60l;
        min = min % 60;
        String s = String.format("%02d:%02d:%02d", hr, min, sec);
        lblGameTime.setText(s);
      }
    };

    private void clearMoveList() {
      moveList.clear();
      movePointer = -1;
    }

    private void clearNewRegion() {
//      if (newRegion != null) {
//        for (Square sqr : newRegion.getContents()) {
//          sqr.setRegion(null);
//          showSqDeselected(sqr);
//        }
//        newRegion.getContents().clear();
//        newRegion = null;
//      }
    }

    private Integer getRegionValue(Region r) throws HeadlessException {
      Integer intval;
      int regSquares = r.getContents().size(); // number of squares in region
      if (inputFromSpinner) {
        RegionValue rv = new RegionValue(JOptionPane.getFrameForComponent(this),
                (regSquares * (regSquares + 1) / 2),
                (regSquares * (2 * BIGSQUARES - regSquares + 1)) / 2);
        intval = rv.getChosenValue();
        rv.setVisible(false);
        return intval;
      } else {
        String val = JOptionPane.showInputDialog(getTopLevelAncestor(),
                "Value for region");
        try {
          intval = Integer.parseInt(val);
        } catch (NumberFormatException ex) {
          return null;
        }
        if (intval >= regSquares * (regSquares + 1) / 2
                && intval
                <= (regSquares * (2 * BIGSQUARES - regSquares + 1)) / 2) {
          return intval;
        }
        return null;
      }
    }

    private void setPointersNull() {
//      for (int i = 0; i < BIGSQUARES; i++) {
//        for (int j = 0; j < BIGSQUARES; j++) {
//          squareArray[i][j].removeMouseListener(this);
//          squareArray[i][j].setParent(null);
//        }
//      }
//      for (Region elem : regions) {
//        elem.setParent(null);
//      }
    }

    private void setPointersThis() {
//      for (int i = 0; i < BIGSQUARES; i++) {
//        for (int j = 0; j < BIGSQUARES; j++) {
//          squareArray[i][j].setParent(this);
//          squareArray[i][j].addMouseListener(this);
//        }
//      }
//      for (Region elem : regions) {
//        elem.setParent(this);
//      }
    }

    /**
     * Restarts a game which is being played. Clears out all squares and history
     */
    void restartGame() {
//      Square s;
//      if (playing) {
//        clearSelections();
//        clearMoveList();
//        tk.EnableSave();
//        for (int i = 0; i < BIGSQUARES; i++) {
//          for (int j = 0; j < BIGSQUARES; j++) {
//            s = squareArray[i][j];
//            s.setValue(0);
//            s.setConfinedToCol(false);
//            s.setConfinedToRow(false);
//            s.setConfinedToSq(false);
//            squaresLeft = BIGSQUARES * BIGSQUARES;
//            changeCustomColour(INITIAL_CUSTOM_COLOUR);
//          }
//        }
//      }
//      repaint();
    }

    /**
     * restores a game from an input stream
     *
     * @param is Object input stream to restore from
     * @return true if succeeded, false otherwise
     */
    boolean restoreGame(ObjectInputStream is) {
//      Object obj;
////      print();
//      initialised = false;
//      mouseSqX = -1;
//      mouseSqY = -1;
//      leftMouseDown = false;
//      newRegion = null;
//      customColour = INITIAL_CUSTOM_COLOUR;
//      darkenCustom();
//      //first clear out any selections and the region list
//      clearSelections();
//      for (Region elem : regions) {
//        remove(elem);
//      }
//      for (int x = 0; x < BIGSQUARES; x++) {
//        for (int y = 0; y < BIGSQUARES; y++) {
//          remove(squareArray[x][y]);
//        }
//      }
//      regions.clear();
//      try {
//        int k = is.readInt();
//        if (k != SAVE_TYPE) {
//          TestKiller.showMessage("Saved type is " + k
//                  + ", should be " + SAVE_TYPE);
//          return false;
//        }
//        k = is.readInt();
//        if (k != SQUARES) {
//          TestKiller.showMessage("Saved size is " + k
//                  + ", should be " + SQUARES);
//          return false;
//        }
//        playing = is.readBoolean();
//        regionId = is.readInt();
//        squareCount = is.readInt();
//        regionTot = is.readInt();
//        gameTime = is.readLong();
//
//        squareArray = (Square[][]) (is.readObject());
////        obj=is.readObject();
//        regions = (HashSet<Region>) (is.readObject());
//        moveList = (ArrayList<Move>) (is.readObject());
//        movePointer = is.readInt();
//
//        customColour = (Color) is.readObject();
//        rbtCustom.setForeground(customColour);
//        btnCustomCol.setForeground(customColour);
//        darkenCustom();
//      } catch (IOException ex) {
//        TestKiller.showMessage("I/O error while restoring game\n"
//                + ex.getLocalizedMessage());
//        return false;
//      } catch (ClassNotFoundException ex) {
//        TestKiller.showMessage("Class error while restoring game\n"
//                + ex.getLocalizedMessage());
//        return false;
//      }
//      if (squareArray[0][0] == null) {
//        System.out.println("SquareArray not initialised properly");
//        return false;
//      }
//      if (regions == null) {
//        System.out.println("Regions not initialised properly");
//        return false;
//      }
//      if (moveList == null) {
//        System.out.println("MoveList not initialised properly");
//        return false;
//      }
//      for (int x = 0; x < BIGSQUARES; x++) {
//        for (int y = 0; y < BIGSQUARES; y++) {
//          add(squareArray[x][y], GRID_LEVEL);
//          squareArray[x][y].setBackColour(NORMAL_BACK_COLOUR);
//        }
//      }
//      setPointersThis();
//
//      for (Region elem : regions) {
////        add(elem, new Integer(REGIONS_LEVEL));
//        add(elem, REGIONS_LEVEL);
//
//        elem.checkNewRegion(elem.getTotal());
//      }
//      disableButtons();
//      if (!playing) {
//        btnStart.setEnabled(squareCount == BIGSQUARES * BIGSQUARES
//                && regionTot == MAX_TOTAL * BIGSQUARES);
//      } else {
//        moveToPlaying();
//        for (int x = 0; x < BIGSQUARES; x++) {
//          for (int y = 0; y < BIGSQUARES; y++) {
//            if (squareArray[x][y].isPermanent()) {
//              squaresLeft--;
//            }
//          }
//        }
//      }
//// in case not updating times
//      javax.swing.SwingUtilities.invokeLater(displayTime);
//      changeSize();
//      repaint();
//      gameFinished = checkEnded();
//      tk.DisableSave();
////      System.out.println("Repainted");
//      System.out.println("Result of audit: " + audit());
////      print();
//      initialised = true;
      return true;
    }

    /**
     * Cleans up GamePanel after unsuccessful restore - cleans out any partially
     * restored lists and arrays - restores to empty game
     */
    void cleanup() {
      regions.clear();
      playing = false;
      regionId = 1;
      squareCount = 0;
      regionTot = 0;

//      for (int x = 0; x < BIGSQUARES; x++) {
//        for (int y = 0; y < BIGSQUARES; y++) {
//          Square sq = squareArray[x][y];
//          sq.setValue(0);
//          sq.setConfinedToCol(false);
//          sq.setConfinedToRow(false);
//          sq.setConfinedToSq(false);
//          sq.setDark(false);
//          sq.setRegion(null);
//          sq.setBackColour(NORMAL_BACK_COLOUR);
//        }
//      }
      clearMoveList();
      customColour = INITIAL_CUSTOM_COLOUR;
      darkenCustom();
      repaint();
    }

    private void disableButtons() {

      btnStart.setEnabled(false);
      rbtPerm.setEnabled(false);
      rbtTemp.setEnabled(false);
      rbtCustom.setEnabled(false);
      rbtCustom2.setEnabled(false);
      btnPtoT.setEnabled(false);
      btnTtoP.setEnabled(false);
      btnSq.setEnabled(false);
      btnRow.setEnabled(false);
      btnCol.setEnabled(false);
      btnSwap.setEnabled(false);
      btnSwapPerm.setEnabled(false);
      btnCustomCol.setEnabled(false);
      btnUndo.setEnabled(false);
      btnRedo.setEnabled(false);
    }

    private void moveToPlaying() {
      playing = true;
      btnStart.setEnabled(false);
      rbtPerm.setEnabled(true);
      rbtTemp.setEnabled(true);
      rbtCustom.setEnabled(true);
      rbtCustom2.setEnabled(true);
      btnSq.setEnabled(true);
      btnRow.setEnabled(true);
      btnCol.setEnabled(true);
      btnSwap.setEnabled(true);
      btnSwapPerm.setEnabled(true);
      btnTtoP.setEnabled(true);
      btnPtoT.setEnabled(true);
      btnCustomCol.setEnabled(true);
      btnUndo.setEnabled(true);
      btnRedo.setEnabled(true);
      rbtTemp.setSelected(true);
//      currColType = CurrentColour.TEMPORARY;
      currentRealColor = TEMP_COLOUR;
      clearSelections();
      squaresLeft = BIGSQUARES * BIGSQUARES;
    }

    /**
     * Gets the square corresponding to an x,y pair
     *
     * @param x X offset (0-8)
     * @param y Y offset (0-8)
     * @return the square
     */
    Square getSquare(int x, int y) {
//      return squareArray[x][y];
return null;
    }

    /**
     * Gets the coordinate in pixels of the start (top or left) of the square
     * given the x- or y- offset
     *
     * @param offset X or Y offset (0-8)
     * @return Coordinate
     */
    int getCoord(int offset) {
      return coordArray[offset];
    }

    int getSquareSize() {
      return squareSize;
    }

    public int getTotalSize() {
      return totalSize;
    }

    void changeSize() {
      makeGridLayer(false);
//      for (Region i : regions) {
//        i.checkNewRegion(i.getTotal());
//      }
    }

    private void makeGridLayer(boolean newSquares) {
//      int currentXCoord;
//      int arrayIndex = 0;
//      Dimension panelDim;
//      int panelSize;
//      Square sq;
//
//      panelDim = this.getSize();
//      panelSize = Math.min(panelDim.height, panelDim.width);
//      // note integer division to round down
//      squareSize = (panelSize - FIXED_WIDTH) / BIGSQUARES;
//      totalSize = FIXED_WIDTH + BIGSQUARES * squareSize;
//
//      currentXCoord = START_X + THICK_WIDTH;
//      for (int BigX = 0; BigX < SQUARES; BigX++) {
//        for (int LittleX = 0; LittleX < SQUARES; LittleX++) {
//          coordArray[arrayIndex++] = currentXCoord;
//          currentXCoord += THIN_WIDTH + squareSize;
//        }
//        currentXCoord += THICK_WIDTH - THIN_WIDTH;
//      }
//
//      for (int xIndex = 0; xIndex < BIGSQUARES; xIndex++) {
//        for (int yIndex = 0; yIndex < BIGSQUARES; yIndex++) {
//          if (newSquares) {
//            sq = new Square(xIndex, yIndex,
//                    Color.RED, NORMAL_BACK_COLOUR, this, squareSize);
//            sq.addMouseListener(this);
//            squareArray[xIndex][yIndex] = sq;
////            add(sq, new Integer(GRID_LEVEL));
//            add(sq,  GRID_LEVEL);
//          } else {
//            squareArray[xIndex][yIndex].updateSize(xIndex, yIndex, squareSize);
//          }
//        }
//      }
    }

    private void addSquareToRegion(Square s) {
//      Region r = s.getRegion();
//// square already belongs to another region
//      if (r != null && r != newRegion) {
//        return;
//      }
//      if (newRegion == null) {
//        newRegion = new Region(regionId++, this);
//      }
//      if (r == null) {
//        newRegion.addSquare(s);
//        showSqSelected(s);
//        s.setRegion(newRegion);
//      } else if (r == newRegion) {
//        newRegion.removeSquare(s);
//        showSqDeselected(s);
//        s.setRegion(null);
//      }
    }

    @Override
    public void paintComponent(Graphics g) {
      Graphics2D g2 = (Graphics2D) g;
//      System.out.println("Painting gridlayer");
      g2.setBackground(Color.BLACK);
      g2.setColor(Color.BLACK);
      g2.fillRect(0, 0, getSize().width, getSize().height);

    }

    private void addRegion(Region r) {
//      if (!regions.contains(r)) {
//        for (Square elem : r.getContents()) {
//          elem.setRegion(r);
//        }
//        regions.add(r);
//        add(r,  REGIONS_LEVEL);
//        regionTot += r.getTotal();
//        r.repaint();
//      }
    }

    private void swapSquares(Square s0, Square s1,
            boolean toPerm, boolean first) {
//      Move m;
//      m = new Move(first, s0);
//      Move m1 = new Move(false, s1);
//      int val0 = s0.getIntValue();
//      int val1 = s1.getIntValue();
//      if (toPerm) {
//        if (s0.hasValue() && !s0.isPermanent()) {
//          squaresLeft--;
//        }
//        if (s1.hasValue() && !s1.isPermanent()) {
//          squaresLeft--;
//        }
//        s0.setTextColour(PERM_COLOUR);
//        s1.setTextColour(PERM_COLOUR);
//        s0.setConfinedToCol(false);
//        s1.setConfinedToCol(false);
//        s0.setConfinedToRow(false);
//        s1.setConfinedToRow(false);
//        s0.setConfinedToSq(false);
//        s1.setConfinedToSq(false);
//      } else {
//        Color c0 = s0.getTextColour();
//        Color c1 = s1.getTextColour();
//        s0.setTextColour(c1);
//        s1.setTextColour(c0);
//        boolean b0 = s0.isConfinedToCol();
//        boolean b1 = s1.isConfinedToCol();
//        s0.setConfinedToCol(b1);
//        s1.setConfinedToCol(b0);
//        b0 = s0.isConfinedToRow();
//        b1 = s1.isConfinedToRow();
//        s0.setConfinedToRow(b1);
//        s1.setConfinedToRow(b0);
//        b0 = s0.isConfinedToSq();
//        b1 = s1.isConfinedToSq();
//        s0.setConfinedToSq(b1);
//        s1.setConfinedToSq(b0);
//      }
//      s0.setValue(val1);
//      s1.setValue(val0);
//      m.updateFromSquare(s0);
//      m1.updateFromSquare(s1);
//      s0.repaint();
//      s1.repaint();
//      addMove(m);
//      addMove(m1);
    }

    private void undoLastMove() {
//      Move m;
//
//      if (movePointer >= 0) {
//        do {
//          m = moveList.get(movePointer--);
//          Square s = squareArray[m.getSqX()][m.getSqY()];
//          boolean oldPerm = s.isPermanent();
//          s.updateFromMoveOld(m);
//          boolean newPerm = s.isPermanent();
//          if (oldPerm && !newPerm) {
//            squaresLeft++;
//          } else if (newPerm && !oldPerm) {
//            squaresLeft--;
//          }
//        } while (!m.isStart() && movePointer >= 0);
//        tk.EnableSave();
//      }
//      gameFinished = checkEnded();
    }

    private void redoNextMove() {
//      Move m;
//      int ls = moveList.size() - 1;
//
//      if (movePointer < ls) {
//        m = moveList.get(++movePointer);
//        while (true) {
//          Square s = squareArray[m.getSqX()][m.getSqY()];
//          boolean oldPerm = s.isPermanent();
//          s.updateFromMoveNew(m);
//          boolean newPerm = s.isPermanent();
//          if (oldPerm && !newPerm) {
//            squaresLeft++;
//          } else if (newPerm && !oldPerm) {
//            squaresLeft--;
//          }
//          if (movePointer < ls) {
//            m = moveList.get(++movePointer);
//            if (m.isStart()) {
//              movePointer--;
//              break;
//            }
//
//          } else {
//            break;
//          }
//        }
//        tk.EnableSave();
//      }
//      gameFinished = checkEnded();
    }

    private void showSqSelected(Square s) {
      s.setBackColour(SELECTED_BACK_COLOUR);
    }

    /**
     *
     * @param s Square to show deselected
     */
    void showSqDeselected(Square s) {
      s.setBackColour(NORMAL_BACK_COLOUR);
    }

    private void showRegSelected(Region r) {
//      for (Square elem : r.getContents()) {
//        elem.setBackColour(SELECTED_REGION_COLOUR);
//      }
    }

    private void showRegDeselected(Region r) {
//      for (Square elem : r.getContents()) {
//        elem.setBackColour(NORMAL_BACK_COLOUR);
//      }
    }

    private void deselectSq(final Square sq) {
      selectedSquares.remove(sq);
      showSqDeselected(sq);
    }

    private void selectSquare(final Square sq) {
      selectedSquares.add(sq);
      showSqSelected(sq);
    }

    private void selectRegion(Region r) {
//      if (!selectedRegions.contains(r)) {
//        selectedRegions.add(r);
//        for (Square elem : r.getContents()) {
//          selectedSquares.add(elem);
//        }
//        showRegSelected(r);
//      }
    }

    private void deselectRegion(Region r) {
//      if (selectedRegions.contains(r)) {
//        selectedRegions.remove(r);
//        for (Square elem : r.getContents()) {
//          selectedSquares.remove(elem);
//        }
//        showRegDeselected(r);
//      }
    }

    /**
     * Clear out all selected sqares and regions Show them as normal and clear
     * selection lists
     */
    void clearSelections() {
//      for (Square elem : selectedSquares) {
//        showSqDeselected(elem);
//      }
//      selectedSquares.clear();
//      for (Region elem : selectedRegions) {
//        showRegDeselected(elem);
//      }
//      selectedRegions.clear();
    }

    /**
     * Checks that a game which the program thinks has ended really has (program
     * bug if not) And then that the Killer Sudoku rules are obeyed.
     *
     * @return true if all OK, false otherwise
     */
    boolean checkEnded() {
//      boolean checkedOK = true;
////      System.out.println("Squares left: "+squaresLeft);
//      // temp code for debugging
//      if (playing) {
//        int permSquares = 0;
//        for (int x = 0; x < BIGSQUARES; x++) {
//          for (int y = 0; y < BIGSQUARES; y++) {
//            if (squareArray[x][y].isPermanent()) {
//              permSquares++;
//            }
//          }
//        }
//        if (permSquares + squaresLeft != BIGSQUARES * BIGSQUARES) {
//          JOptionPane.showMessageDialog(this,
//                  "Program bug: squaresLeft=" + squaresLeft
//                  + ", permSquares=" + permSquares,
//                  "Square error", JOptionPane.ERROR_MESSAGE);
//          return false;
//        }
//      }
//      //end of temp code
//
//      if (playing && (squaresLeft == 0)) {
//        Square[] checkArray = new Square[BIGSQUARES + 1];
//// first check all columns contain 1-9 and are permanent (that would be a bug)
//        for (int x = 0; x < BIGSQUARES; x++) {
//          for (int i = 0; i < checkArray.length; i++) {
//            checkArray[i] = null;
//          }
//          //run down column and mark all values
//          for (int y = 0; y < BIGSQUARES; y++) {
//            Square s = squareArray[x][y];
//            Square checkS = checkArray[s.getIntValue()];
////  check that value has already occurred in the column
//            if (checkS != null) {
//              s.setBackColour(ERROR_BACK_COLOUR);
//              checkS.setBackColour(ERROR_BACK_COLOUR);
//              checkedOK = false;
//            }
//            if (!s.isPermanent()) {
//              checkedOK = false;
//              s.setBackColour(BUG_BACK_COLOUR);
//            }
//            checkArray[s.getIntValue()] = s;
//          }
//        }
//
//        //now check the rows
//        for (int y = 0; y < BIGSQUARES; y++) {
//          for (int i = 0; i < checkArray.length; i++) {
//            checkArray[i] = null;
//          }
//          for (int x = 0; x < BIGSQUARES; x++) {
//            Square s = squareArray[x][y];
//            Square checkS = checkArray[s.getIntValue()];
//// check that value has already occurred in the column
//            if (checkS != null) {
//
//              s.setBackColour(ERROR_BACK_COLOUR);
//              checkS.setBackColour(ERROR_BACK_COLOUR);
//              checkedOK = false;
//            }
//            if (!s.isPermanent()) {
//              checkedOK = false;
//              s.setBackColour(BUG_BACK_COLOUR);
//            }
//            checkArray[s.getIntValue()] = s;
//          }
//
//        }
//
//        // now check the big squares
//        for (int xsq = 0; xsq < BIGSQUARES; xsq += SQUARES) {
//          for (int ysq = 0; ysq < BIGSQUARES; ysq += SQUARES) {
//
//            // each big square - first reset the check array
//            for (int i = 0; i < checkArray.length; i++) {
//              checkArray[i] = null;
//            }
//            for (int x = 0; x < SQUARES; x++) {
//              for (int y = 0; y < SQUARES; y++) {
//                Square s = squareArray[xsq + x][xsq + y];
//                Square checkS = checkArray[s.getIntValue()];
//// check that value has already occurred in the column
//                if (checkS != null) {
//
//                  s.setBackColour(ERROR_BACK_COLOUR);
//                  checkS.setBackColour(ERROR_BACK_COLOUR);
//                  checkedOK = false;
//                }
//                if (!s.isPermanent()) {
//                  checkedOK = false;
//                  s.setBackColour(BUG_BACK_COLOUR);
//                }
//                checkArray[s.getIntValue()] = s;
//              }
//            }
//          }
//        }
//
//        //now check the regions
//        for (Region r : regions) {
//          int sum = 0;
//          for (int i = 0; i < checkArray.length; i++) {
//            checkArray[i] = null;
//          }
//          for (Square s : r.getContents()) {
//            int val = s.getIntValue();
//            Square checkS = checkArray[val];
//            if (checkS != null) {
//              checkedOK = false;
//              s.setBackColour(ERROR_BACK_COLOUR);
//              checkS.setBackColour(ERROR_BACK_COLOUR);
//            }
//            checkArray[val] = s;
//            sum += val;
//          }
//          if (sum != r.getTotal()) {
//            for (Square s : r.getContents()) {
//              s.setBackColour(ERROR_BACK_COLOUR); // region sum wrong
//              checkedOK = false;
//            }
//          }
//        }
//
//        // now display result
//        if (checkedOK) {
//          JOptionPane.showMessageDialog(this,
//                  "Well done, you've finished it", "Success!",
//                  JOptionPane.INFORMATION_MESSAGE);
//        } else {
//          JOptionPane.showMessageDialog(this,
//                  "Oh dear, there's been a mistake", "Failure",
//                  JOptionPane.INFORMATION_MESSAGE);
//          for (int x = 0; x < BIGSQUARES; x++) {
//            for (int y = 0; y < BIGSQUARES; y++) {
//              squareArray[x][y].setBackColour(NORMAL_BACK_COLOUR);
//            }
//          }
//        }
//        clearSelections();
//        return checkedOK;
//      }
      return false;
    }

    private boolean audit() {
      boolean result = true;
//      for (int x = 0; x < BIGSQUARES; x++) {
//        for (int y = 0; y < BIGSQUARES; y++) {
//          Square sq = squareArray[x][y];
//          Region r = sq.getRegion();
//          if (r != null) {
//            if (!r.getContents().contains(sq)) {
//              System.out.println("Square " + x + "," + y
//                      + " says it's in region " + r.getName());
//              result = false;
//            }
//          }
//          if (sq.getXIndex() != x || sq.getYIndex() != y) {
//            System.out.println("Square " + x + "," + y
//                    + " has coords " + sq.getXIndex() + "," + sq.getYIndex());
//            result = false;
//          }
//        }
//      }
//      for (Region r : regions) {
//        for (Square s : r.getContents()) {
//          if (s.getRegion() != r) {
//            System.out.println("Region " + r.getName()
//                    + " contains square " + s.getName());
//            System.out.println("  Its region is "
//                    + (r.getName()));
//            result = false;
//          }
//        }
//      }
      return result;
    }

//    private void print() {
//      Component[] cList = getComponents();
//      System.out.println("Printing Gamepanel components");
//      for (int i = 0; i < cList.length; i++) {
//        Component c = cList[i];
//        System.out.println(c.toString());
//        System.out.println(" Bounds " + c.getBounds());
//        System.out.println(" Layer " + getLayer(c));
//        if (c instanceof Container) {
//          printContainer((Container) c, "  ");
//        }
//        if (c instanceof Square) {
//          ((Square) c).print();
//        }
//      }
//      System.out.println("Region list");
//      for (Region elem : regions) {
//        elem.print();
//      }
//      System.out.println("Move list");
//      for (Iterator it = moveList.iterator(); it.hasNext();) {
//        Move elem = (Move) it.next();
//        elem.print();
//      }
////      for (Move elem : moveList) {
////        elem.print();
////      }
//      System.out.println("Selected squares");
//      for (Square sq : selectedSquares) {
//        System.out.println("  " + sq.getName());
//      }
//      System.out.println("Selected regions");
//      for (Region reg : selectedRegions) {
//        System.out.println("  " + reg.getName());
//      }
//      System.out.println("Key listener list");
//      for (KeyListener elem : this.getKeyListeners()) {
//        System.out.println("Listener " + elem);
//      }
//      System.out.println("Square button action listeners");
//      for (ActionListener elem : btnSq.getActionListeners()) {
//        System.out.println("  " + elem);
//      }
//    }
    private void printContainer(Container c, String preString) {
      int i;
      Component[] cList1 = c.getComponents();
      for (i = 0; i < Math.min(cList1.length, 10); i++) {
        Component comp = cList1[i];
        System.out.println(preString + comp.toString());
        System.out.println(preString + " Bounds " + comp.getBounds());
        if (comp instanceof Container) {
          printContainer((Container) comp, preString + "  ");
        }
      }
      if (i != cList1.length) {
        System.out.println(preString + "(" + cList1.length
                + " components in total");
      }
    }

    private void darken(Square s, boolean force) {
      if (!s.isDark() || force) {
        Color c = s.getBackColour();
        if (c == NORMAL_BACK_COLOUR) {
          s.setBackColour(DARK_NORMAL_COLOUR);
        } else if (c == SELECTED_BACK_COLOUR) {
          s.setBackColour(DARK_SEL_BACK_COLOUR);
        } else if (c == SELECTED_REGION_COLOUR) {
          s.setBackColour(DARK_SEL_REGION_COLOUR);
        }
        s.setDark(true);

      }
    }

    private void lighten(Square s) {
      if (s.isDark()) {
        Color c = s.getBackColour();
        if (c == DARK_NORMAL_COLOUR) {
          s.setBackColour(NORMAL_BACK_COLOUR);
        } else if (c == DARK_SEL_BACK_COLOUR) {
          s.setBackColour(SELECTED_BACK_COLOUR);
        } else if (c == DARK_SEL_REGION_COLOUR) {
          s.setBackColour(SELECTED_REGION_COLOUR);
        }
        s.setDark(false);

      }
    }

    // Event listeners
    @Override
    public void mouseClicked(MouseEvent e) {
//      boolean wasSelected;
//      boolean ctrlPressed;
////      boolean shiftPressed;
//      boolean altPressed;
//      Integer intval;
//      Object s = e.getSource();
////      int mods = e.getModifiers();
////      ctrlPressed = ((mods & MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK);
////      shiftPressed = ((mods & MouseEvent.SHIFT_MASK) == MouseEvent.SHIFT_MASK);
//      ctrlPressed = e.isControlDown();
////      shiftPressed = e.isShiftDown();
//      altPressed = e.isAltDown();
//      if (!playing && (SwingUtilities.isRightMouseButton(e) ||
//              (altPressed && SwingUtilities.isLeftMouseButton(e)) )) {
//        // setting up and getting total region - doesn't matter where the click is
//        if (newRegion != null) {
//          if (newRegion.getContents().size() <= BIGSQUARES) {
//            intval = getRegionValue(newRegion);
//            if (intval != null) {
//              if (newRegion.checkNewRegion(intval)) {
//                addRegion(newRegion);
//                squareCount += newRegion.getContents().size();
//                tk.EnableSave();
//              } else { // could not set up new region - back everything out
//                clearNewRegion();
//              }
//              newRegion = null;
//            }
//          } //if region too big - ignore click
//        } else {
//          //region selected was an existing one (if any)
//          // retotal if only one
//          if (selectedRegions.size() == 1) {
//            int oldVal;
//            newRegion = selectedRegions.iterator().next();
//            oldVal = newRegion.getTotal();
//            intval = getRegionValue(newRegion);
//            if (intval != null) {
//              newRegion.setTotal(intval);
//              regionTot += intval - oldVal;
//              newRegion.repaint();
//            }
//          } else if (!selectedRegions.isEmpty()) {
//            TestKiller.showMessage("Must select a single region to retotal");
//          }
//          newRegion = null;
//        }
//
//        if (squareCount == BIGSQUARES * BIGSQUARES) {
//          if (regionTot == MAX_TOTAL * BIGSQUARES) {
//            btnStart.setEnabled(true);
//          } else {
//            TestKiller.showMessage("Region totals have incorrect sum: "
//                    + regionTot + " should be " + MAX_TOTAL * BIGSQUARES);
//          }
//        }
//
//      } else {
//
//        if (s instanceof Square) {
//          Square sq = (Square) s;
////        System.out.println("Square mouse clicked "+sq.getXIndex()+
////          ","+sq.getYIndex()+":"+
////            e.getClickCount());
////        if (ctrlPressed || shiftPressed) {
////          System.out.println("  "+(ctrlPressed?"ctrl ":" ")+
////          (shiftPressed?"shift":""));
////        }
//          if (SwingUtilities.isLeftMouseButton(e)) {
//            if (playing) {
//              if (altPressed) {
//                displayRegionTotal();
//              }
//              else if (e.getClickCount() == 1) {
//                wasSelected = (selectedSquares.contains(sq));
//                if (!ctrlPressed) {
//                  clearSelections();
//                  if (!wasSelected) {
//                    selectSquare(sq);
//                  }
//                } else if (!selectedRegions.contains(sq.getRegion())) {
//                  //only toggle if not in a selected region
//                  if (wasSelected) {
//                    deselectSq(sq);
//                  } else {
//                    selectSquare(sq);
//                  }
//                }
//
//              } else {  // double-click - work on region
//
//                Region r = sq.getRegion();
//                wasSelected = (selectedRegions.contains(r));
//                if (!ctrlPressed) {
//                  clearSelections();
//                  if (!wasSelected) {
//                    selectRegion(r);
//                  }
//                } else {  // ctrl-double click
//
//                  if (wasSelected) {
//                    deselectRegion(r);
//                  } else {  // new selection
//                    //first remove any selected squares in that region
//
//                    for (Square regionSq : r.getContents()) {
//                      selectedSquares.remove(regionSq);
//                    }
//                    selectRegion(r);
//                  }
//                }
//              }
//              darken(sq, true);
//            } else {  //setting up - only regions selectable
//
//              if (e.getClickCount() > 1) { //only double-click allowed
//                //single-click handled by mouse pressed/released
//
//                Region r = sq.getRegion();
//                if (r != null && r != newRegion) {
//                  clearNewRegion();
//                  if (selectedRegions.contains(r)) {
//                    deselectRegion(r);
//                  } else {
//                    selectRegion(r);
//                  }
//                }
//              }
//            }
//          } else if (SwingUtilities.isRightMouseButton(e)) {
//            if (playing) {
//              displayRegionTotal();
//            } else {    //setting up - should not happen
//              System.out.println("Mouse code wrong");
//
//            }
//
//          }
//
//        } else {
//          System.out.println("Unknown mouse click "
//                  + e.getX() + "," + e.getY());
//        }
//      }
    }

    void displayRegionTotal() throws HeadlessException {
//      int total = 0;
//      for (Region r : selectedRegions) {
//        total += r.getTotal();
//      }
//      for (Square sq1 : selectedSquares) {
//        if (!selectedRegions.contains(sq1.getRegion())) {
//          total += sq1.getIntValue();
//        }
//      }
//      int bigCount = total / MAX_TOTAL;
//      int bigRem = total % MAX_TOTAL;
//      String remString = "+" + bigRem;
//      if (bigRem > MAX_TOTAL / 2) {
//        bigCount += 1;
//        bigRem -= MAX_TOTAL;
//        remString = "" + bigRem;
//      }
//      JOptionPane.showMessageDialog(this,
//              (total == 0 ? "No values in selection"
//                      : "Total is " + total + "=" + MAX_TOTAL + "*"
//                              + bigCount + remString),
//              "Total for selected squares",
//              JOptionPane.INFORMATION_MESSAGE);
    }

    @Override
    public void mousePressed(MouseEvent e) {
//      if (SwingUtilities.isLeftMouseButton(e)) {
//        leftMouseDown = true;
//      }
//      Object s = e.getSource();
//      if (s instanceof Square) {
//        Square sq = (Square) s;
//        //        System.out.println("Square mouse pressed "+
////        sq.getXIndex()+","+sq.getYIndex());
//
//        if (SwingUtilities.isLeftMouseButton(e) && !e.isAltDown()) {
//          if (!playing) {
//            for (Region r : selectedRegions) {
//              deselectRegion(r);
//            }
//            addSquareToRegion(sq);
//          } else { //playing - start a drag
//            draggedSquare = sq;
//            initialDraggedSquare = sq;
//            firstDrag = true;
//          }
//        }
//      }
//    }
//
//    @Override
//    public void mouseReleased(MouseEvent e) {
//      if (SwingUtilities.isLeftMouseButton(e)) {
//        leftMouseDown = false;
//        if (playing) {
//          draggedSquare = null;
//          initialDraggedSquare = null;
//          firstDrag = false;
//          gameFinished = checkEnded();
//        }
//      }
//    }
//
//    @Override
//    public void mouseEntered(MouseEvent e) {
//      Square sq;
//      tk.toFront();
//      if (leftMouseDown & !playing) {
//        mousePressed(e);
//      }
//      Object s = e.getSource();
//      if (s instanceof Square) {
//        sq = (Square) s;
//        mouseSqX = sq.getXIndex();
//        mouseSqY = sq.getYIndex();
//        darken(sq, false);
//        if (playing) {
//          if (draggedSquare != null) {
//            swapSquares(sq, draggedSquare, false, firstDrag);
//            if (e.isControlDown()) {
//              swapSquares(draggedSquare, initialDraggedSquare, false, false);
//            }
//            firstDrag = false;
//            draggedSquare = sq;
//          }
//        }
//      }
//      requestFocusInWindow();
    }

    @Override
    public void mouseExited(MouseEvent e) {
//      Square sq;
//      Object s = e.getSource();
//      if (s instanceof Square) {
//        sq = (Square) s;
//        lighten(sq);
//        if (playing) {
////        System.out.println("Exit and lighten "+ mouseSqX+", "+mouseSqY);
//          if (mouseSqX == sq.getXIndex() && mouseSqY == sq.getYIndex()
//                  && !selectedSquares.contains((Square) s)) {
//            mouseSqX = -1;
//            mouseSqY = -1;
//          }
//        }
//      }
    }

    /**
     * Called when a character key is pressed
     *
     * @param e The KeyEvent which caused the call
     *
     * characters: 1-9: put value in square 0 or space: delete values in square
     * -: toggle confined to row marker *: toggle confined to bigsquare marker
     * /: toggle confined to column marker +: swap selected squares .: change
     * permanent to temp, change non-permanent to permanent S: swap selected
     * squares P: set current colour to Permanent T: set current colour to
     * Temporary C: set current colour to Custom backspace: undo last move
     */
    @Override
    public void keyTyped(KeyEvent e) {
//      char c = Character.toUpperCase(e.getKeyChar());
//      if (playing) {
//        if (mouseSqX >= 0) {
//          Square s = squareArray[mouseSqX][mouseSqY];
//          Move m;
//
//          if ('1' <= c && c <= '9') {
//            m = new Move(true, s);
//            int newval = c - '0';
//            if ((!s.isPermanent()) && currentRealColor.equals(PERM_COLOUR)) {
//              squaresLeft--;
//            }
//            if (s.isPermanent() && (!currentRealColor.equals(PERM_COLOUR))) {
//              squaresLeft++;
//            }
//            s.setTextColour(currentRealColor);
//            s.setValue(newval);
//            s.repaint();
//            m.updateFromSquare(s);
//            addMove(m);
//          } else if (c == '0' || c == ' ') {
//            if (s.getIntValue() != 0) {
//              m = new Move(true, s);
//              if (s.isPermanent()) {
//                squaresLeft++;
//              }
//              s.setConfinedToCol(false);
//              s.setConfinedToRow(false);
//              s.setConfinedToSq(false);
//              s.setValue(0);
//              s.repaint();
//              m.updateFromSquare(s);
//              addMove(m);
//            }
//          } else if ((c == '-') && s.hasValue()) {
//            m = new Move(true, s);
//            s.toggleConfineRow();
//            m.updateFromSquare(s);
//            addMove(m);
//          } else if ((c == '/') && s.hasValue()) {
//            m = new Move(true, s);
//            s.toggleConfineCol();
//            m.updateFromSquare(s);
//            addMove(m);
//          } else if ((c == '*') && s.hasValue()) {
//            m = new Move(true, s);
//            s.toggleConfineSq();
//            m.updateFromSquare(s);
//            addMove(m);
//          } else if (c == '+') {
//            swapSelSquares(false);
//// swap temp and perm colours
//          } else if ((c == '.') && s.hasValue()) {
//            m = new Move(true, s);
//            if (s.hasValue()) {
//              if (s.isPermanent()) {
//                s.setTextColour(TEMP_COLOUR);
//                squaresLeft++;
//              } else {
//                s.setTextColour(PERM_COLOUR);
//                s.setConfinedToCol(false);
//                s.setConfinedToRow(false);
//                s.setConfinedToSq(false);
//                squaresLeft--;
//              }
//            }
//            s.repaint();
//            m.updateFromSquare(s);
//            addMove(m);
//          }
//        }
//
//        switch (c) {
//          case '\b':
//            undoLastMove();
//            break;
//
//          case 'P':
//            rbtPerm.setSelected(true);
//            currentRealColor = PERM_COLOUR;
//            break;
//
//          case 'T':
//            rbtTemp.setSelected(true);
//            currentRealColor = TEMP_COLOUR;
//            break;
//
//          case 'C':
//            rbtCustom.setSelected(true);
//            currentRealColor = customColour;
//            break;
//
//          case 'S':
//            swapSelSquares(false);
//            break;
//
//          default:
//            break;
//        }
//
//      }
//      if (!gameFinished) {
//        gameFinished = checkEnded();
//      }
    }

    private void addMove(final Move m) {
//      for (int i = moveList.size() - 1; i > movePointer; i--) {
//        moveList.remove(i);
//      }
//      moveList.add(m);
//      movePointer++;
//      tk.EnableSave();
    }

    @Override
    public void keyPressed(KeyEvent e) {
//      int i = e.getKeyCode();
//      String s = KeyEvent.getKeyText(i);
//      if ("Escape".equals(s) && tk != null) {
//        tk.minimiseMe();
//      } else if (playing) {
//        if (e.isControlDown()) {
//          if (i == KeyEvent.VK_RIGHT || i == KeyEvent.VK_KP_RIGHT) {
//            redoNextMove();
//          } else if (i == KeyEvent.VK_LEFT || i == KeyEvent.VK_KP_LEFT) {
//            undoLastMove();
//          }
//        }
//      } else {
//        if (i == KeyEvent.VK_DELETE) {
//          for (Region r : selectedRegions) {
//            regionTot -= r.getTotal();
//            squareCount -= r.getSquareCount();
//            for (Square sq : r.getContents()) {
//              sq.setRegion(null);
//            }
//            showRegDeselected(r);
//            remove(r);
//            regions.remove(r);
//            repaint(r.getBounds());
//          }
//          selectedRegions.clear();
////        System.out.println("New region total "+regionTot+
////          ", square count "+squareCount);
////        repaint();
//        }
//      }
////      System.out.println("Key "+i+", "+s+" pressed");
    }

    @Override
    public void keyReleased(KeyEvent e) {
    }

    @Override
    public void actionPerformed(ActionEvent e) {
//      Move m;
//      boolean firstMove = true;
//
//      Object o = e.getSource();
//      if (o == btnStart) {
//        if (squareCount == BIGSQUARES * BIGSQUARES
//                && regionTot == MAX_TOTAL * BIGSQUARES) {
//          moveToPlaying();
//        } else {
//          TestKiller.showMessage("Totals incorrect - program error!");
//        }
//      } else if (o == rbtPerm) {
////        currColType = CurrentColour.PERMANENT;
//        currentRealColor = PERM_COLOUR;
//      } else if (o == rbtTemp) {
////        currColType = CurrentColour.TEMPORARY;
//        currentRealColor = TEMP_COLOUR;
//      } else if (o == rbtCustom) {
////        currColType = CurrentColour.CUSTOM;
//        currentRealColor = customColour;
//      } else if (o == rbtCustom2) {
////        currColType = CurrentColour.CUSTOM2;
//        currentRealColor = customColour2;
//      } else if (o == btnSq) {
//        for (Square s : selectedSquares) {
//          m = new Move(firstMove, s);
//          firstMove = false;
//          s.toggleConfineSq();
//          m.updateFromSquare(s);
//          addMove(m);
//        }
//
//      } else if (o == btnRow) {
//        for (Square s : selectedSquares) {
//          m = new Move(firstMove, s);
//          firstMove = false;
//          s.toggleConfineRow();
//          m.updateFromSquare(s);
//          addMove(m);
//        }
//
//      } else if (o == btnCol) {
//        for (Square s : selectedSquares) {
//          m = new Move(firstMove, s);
//          firstMove = false;
//          s.toggleConfineCol();
//          m.updateFromSquare(s);
//          addMove(m);
//        }
//
//      } else if (o == btnTtoP) {
//        for (Square s : selectedSquares) {
//          m = new Move(firstMove, s);
//          firstMove = false;
//          if (s.hasValue() && !s.isPermanent()) {
//            squaresLeft--;
//          }
//          s.setTextColour(PERM_COLOUR);
//          s.setConfinedToCol(false);
//          s.setConfinedToRow(false);
//          s.setConfinedToSq(false);
//          s.repaint();
//          m.updateFromSquare(s);
//          addMove(m);
//        }
//      } else if (o == btnPtoT) {
//        for (Square s : selectedSquares) {
//          m = new Move(firstMove, s);
//          firstMove = false;
//          if (s.hasValue() && s.isPermanent()) {
//            squaresLeft++;
//          }
//          s.setTextColour(TEMP_COLOUR);
//          s.setConfinedToCol(false);
//          s.setConfinedToRow(false);
//          s.setConfinedToSq(false);
//          s.repaint();
//          m.updateFromSquare(s);
//          addMove(m);
//        }
//      } else if (o == btnSwap) {
//        swapSelSquares(false);
//      } else if (o == btnSwapPerm) {
//        swapSelSquares(true);
//      } else if (o == btnCustomCol) {
//        jd.setVisible(true);
//      } else if (o == btnUndo) {
//        undoLastMove();
//      } else if (o == btnRedo) {
//        redoNextMove();
//      } else if (o instanceof JButton) {
//        JButton jb = (JButton) o;
//        if (jb.getRootPane() == jd.getRootPane()) {
//          String s = e.getActionCommand();
//          if (s.equals("OK")) {
//            changeCustomColour(cc.getColor());
//          }
//        }
//      } else {
//        TestKiller.showMessage("program error - non-button action from source "
//                + o);
//      }
//      gameFinished = checkEnded();
    }

    private void changeCustomColour(final Color newColour) {
      if (newColour != null) {
        customColour = newColour;
        rbtCustom.setForeground(customColour);
        btnCustomCol.setForeground(customColour);
        if (rbtCustom.isSelected()) {
          currentRealColor = customColour;
        }
        darkenCustom();
      }
      tk.EnableSave();
    }

    private void darkenCustom() {
      customColour2 = customColour.darker();
      rbtCustom2.setForeground(customColour2);
      if (rbtCustom2.isSelected()) {
        currentRealColor = customColour2;
      }
    }

    private void swapSelSquares(boolean toPerm) {
//      Move m;
//      Square s;
//      Square s0 = null;
//      Square s1 = null;
//      boolean swapping;
////      Object[] swapArray;
//
//      swapping = (selectedSquares.size() == 2);
//      for (Iterator it = selectedSquares.iterator(); it.hasNext();) {
//        Object elem = it.next();
//        if (elem instanceof Square) {
//          s = (Square) elem;
//          if (swapping || !s.isPermanent()) {
//            if (s0 == null) {
//              s0 = s;
//            } else if (s1 == null) {
//              s1 = s;
//            } else {
//              return;
//            }
//          }
//        }
//      }
//      if (s0 != null && s1 != null) {
//        swapSquares(s0, s1, toPerm, true);
//      }
    }

    void addListeners() {
      btnStart.addActionListener(this);
      rbtPerm.addActionListener(this);
      rbtTemp.addActionListener(this);
      rbtCustom.addActionListener(this);
      rbtCustom2.addActionListener(this);
      btnPtoT.addActionListener(this);
      btnTtoP.addActionListener(this);
      btnSq.addActionListener(this);
      btnRow.addActionListener(this);
      btnCol.addActionListener(this);
      btnSwap.addActionListener(this);
      btnSwapPerm.addActionListener(this);
      btnCustomCol.addActionListener(this);
      btnUndo.addActionListener(this);
      btnRedo.addActionListener(this);
      addMouseListener(this);
      addKeyListener(this);
    }

    @Override
    public void mouseReleased(MouseEvent e) {
      throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void mouseEntered(MouseEvent e) {
      throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
  }
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.ButtonGroup bgColours;
  private javax.swing.JButton btnCol;
  private javax.swing.JButton btnCustomCol;
  private javax.swing.JButton btnPtoT;
  private javax.swing.JButton btnRedo;
  private javax.swing.JButton btnRow;
  private javax.swing.JButton btnSq;
  private javax.swing.JButton btnStart;
  private javax.swing.JButton btnSwap;
  private javax.swing.JButton btnSwapPerm;
  private javax.swing.JButton btnTtoP;
  private javax.swing.JButton btnUndo;
  private javax.swing.Box.Filler filler1;
  private javax.swing.JLabel lblGameTime;
  private javax.swing.JPanel pnlButtons;
  private javax.swing.JPanel pnlColourButtons;
  private javax.swing.JRadioButton rbtCustom;
  private javax.swing.JRadioButton rbtCustom2;
  private javax.swing.JRadioButton rbtPerm;
  private javax.swing.JRadioButton rbtTemp;
  // End of variables declaration//GEN-END:variables
}
